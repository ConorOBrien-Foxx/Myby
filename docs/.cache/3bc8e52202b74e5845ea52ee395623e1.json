[{"answer_id":265142,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/265142#265142","body":"<h1><a href=\"https://github.com/AlephAlpha/Nekomata\" rel=\"nofollow noreferrer\">Nekomata</a>, 5 bytes</h1>\n<pre><code>ᵃƂ×Öƃ\n</code></pre>\n<p><a href=\"https://ato.pxeger.com/run?1=m70iLzU7PzexJHFZtJJurlLsgqWlJWm6Fqsfbm0-1nR4-uFpx5qXFCclF0PFF9w0N1Aw5DJUMOKyVDDgMgOyjRWMuYwUTLnMFSy5DI0VDA25TBUMzbkMTRQMjbkMLYEqzIwVzIwh-gE\" rel=\"nofollow noreferrer\">Attempt This Online!</a></p>\n<pre><code>ᵃƂ×Öƃ\nᵃƂ      Convert both inputs to binary digits\n  ×     Convolve\n   Ö    Modulo 2\n    ƃ   Convert back to decimal\n</code></pre>\n"},{"answer_id":264899,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/264899#264899","body":"<h1><a href=\"https://www.wolfram.com/wolframscript/\" rel=\"nofollow noreferrer\">Wolfram Language (Mathematica)</a> v13.3+, 38 bytes</h1>\n<pre><code>(F=2~FiniteField~+##;F@#2F@#)@&quot;Index&quot;&amp;\n</code></pre>\n<p>Input <code>[a, b]</code>.</p>\n<p><a href=\"https://reference.wolfram.com/language/guide/SummaryOfNewFeaturesIn133#107245402\" rel=\"nofollow noreferrer\">Version 13.3</a> introduced <a href=\"https://reference.wolfram.com/language/ref/FiniteField.html\" rel=\"nofollow noreferrer\"><code>FiniteField</code></a>, which is nicer to golf with than <a href=\"https://reference.wolfram.com/language/FiniteFields/ref/GF.html\" rel=\"nofollow noreferrer\"><code>FiniteFields`GF</code></a>. Getting an integer out of a <code>FiniteFieldElement</code> is still a little verbose, though.</p>\n<p><a href=\"https://i.sstatic.net/m82r2.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/m82r2.png\" alt=\"test cases\" /></a></p>\n"},{"answer_id":264189,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/264189#264189","body":"<h1><a href=\"https://github.com/bsoelch/OneChar.js/blob/main/ItrLang.md\" rel=\"nofollow noreferrer\">Itr</a>, 9 bytes</h1>\n<p><code>BàBC*µRxB</code></p>\n<p><a href=\"https://bsoelch.github.io/OneChar.js/?lang=Itr&amp;src=QuBCQyq1UnhC&amp;in=MyAz\" rel=\"nofollow noreferrer\">online interpreter</a></p>\n<h2>Explanation</h2>\n<pre><code>            ; implicit input\nBàB         ; convert input to bit lists\n   C*µRx    ; polynomial multiplication in F2[X]\n        B   ; convert bit-list to number\n            ; implicit output\n</code></pre>\n"},{"answer_id":257569,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/257569#257569","body":"<h1><a href=\"https://github.com/mudkip201/pyt\" rel=\"nofollow noreferrer\">Pyt</a>, 37 bytes</h1>\n<pre><code>ɓąƖĐŁř⁻↔2⇹^**ĐŁ2%¬?ŕ:ŕÁ0á;ĐŁ`ŕʁ⊻ĐŁ⁻łŕ\n</code></pre>\n<p><a href=\"https://tio.run/##K6gs@f//5OQjrcemHZlwtPHozEeNux@1TTF61L4zTksLJGSkemiN/dGpVkenHm40OLzQGiSWcHTqqcZHXbtBbKCGo01Hp/7/b2jCZWgMAA\" rel=\"nofollow noreferrer\" title=\"Pyt – Try It Online\">Try it online!</a></p>\n<p>Takes two integers a,b on separate lines</p>\n<p>The following is worked on a=13, b=14</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Code</th>\n<th>Stack</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ɓąƖ</td>\n<td>[1,1,0,1]</td>\n<td>Pushes the <strong>ą</strong>rray corresponding to the <strong>ɓ</strong>its of 13</td>\n</tr>\n<tr>\n<td>ĐŁř⁻↔2⇹^*</td>\n<td>[8,4,0,1]</td>\n<td>Converts array to corresponding powers of 2</td>\n</tr>\n<tr>\n<td>*</td>\n<td>[112,56,0,14]</td>\n<td>Multiplies the array by 14</td>\n</tr>\n<tr>\n<td>ĐŁ2%¬?</td>\n<td>[112,56,0,14], True</td>\n<td>does the array have an even length?</td>\n</tr>\n<tr>\n<td>ŕ</td>\n<td>[112,56,0,14]</td>\n<td>If so, pop the boolean check</td>\n</tr>\n<tr>\n<td>:ŕÁ0á</td>\n<td>(skipped in this run)</td>\n<td>Otherwise, append a 0 to the array</td>\n</tr>\n<tr>\n<td>;ĐŁ`ŕʁ⊻ĐŁ⁻ł</td>\n<td>[70], 0</td>\n<td><strong>ʁ</strong>educe the array using XOR (<strong>⊻</strong>) while the <strong>Ł</strong>ength of the resulting array is greater than 1</td>\n</tr>\n<tr>\n<td>ŕ</td>\n<td>[70]</td>\n<td><strong>ŕ</strong>emove the 0; implicit print</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"answer_id":256279,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/256279#256279","body":"<h1><a href=\"https://github.com/Vyxal/Vyxal\" rel=\"nofollow noreferrer\">Vyxal</a>, 9 bytes</h1>\n<pre><code>₌0b(dn⁰*꘍\n</code></pre>\n<p><a href=\"https://vyxal.pythonanywhere.com/#WyJBIiwiIiwi4oKMMGIoZG7igbAq6piNIiwiIiwiMTMsIDE0XG4wLCAxXG4xLCAyXG4xMywgMTFcbjE5LCAxXG42MywgNjNcbjIsIDUiXQ==\" rel=\"nofollow noreferrer\">Try it Online!</a></p>\n<p>Ports the 05AB1E answer, so go upvote that too</p>\n<h2>Explained</h2>\n<pre><code>₌0b(dn⁰*꘍\n₌0b       # Push 0 and the binary of the first input\n   (      # to each bit:\n    d     # double the top of the stack\n     n⁰*  # multiply the bit by the second input\n        ꘍ # and bit xor\n</code></pre>\n"},{"answer_id":252208,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/252208#252208","body":"<h1><a href=\"https://github.com/Adriandmen/05AB1E/wiki/Commands\" rel=\"nofollow noreferrer\">05AB1E</a>, 8 <a href=\"https://github.com/Adriandmen/05AB1E/wiki/Codepage\" rel=\"nofollow noreferrer\">bytes</a></h1>\n<pre><code>Îbv·yI*^\n</code></pre>\n<p><a href=\"https://tio.run/##yy9OTMpM/f//cF9S2aHtlZ5acf//G5pwGRoDAA\" rel=\"nofollow noreferrer\">Try it online</a> or <a href=\"https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfWVC6H@D4qSyQ9srI7Ti/tfq/I@ONtAxjNWJNtQxApKWOgZA0gwsYqxjDCSNdEyBpLmOJUiNsY4hSMZUx9AcxDXRMQQpMbQEqzcz1jEzjo0FAA\" rel=\"nofollow noreferrer\">verify all test cases</a>.</p>\n<p><strong>Explanation:</strong></p>\n\n<pre class=\"lang-python prettyprint-override\"><code>Î         # Push 0 and the first input\n b        # Convert it to a binary string\n  v       # Loop over each bit `y` of this string:\n   ·      #  Double the current integer\n    y     #  Push bit `y`\n     I*   #  Multiply it by the second input\n       ^  #  Bitwise-XOR the two together\n          # (after the loop, the result is output implicitly)\n</code></pre>\n"},{"answer_id":252199,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/252199#252199","body":"<h1><a href=\"https://github.com/DennisMitchell/jelly\" rel=\"nofollow noreferrer\">Jelly</a>, <s>7</s> 6 bytes</h1>\n<pre><code>Bæc/ḂḄ\n</code></pre>\n<p><a href=\"https://tio.run/##DcwxCgIxEAXQfk7xWysziZmY1kMI1mIjewFLF0HwIBZiJStEtHLBe8xeZJzu8/j/73dddzBbjdftXFuv7WT6Hr5PbY/11N/1dZuOn/H8u8w2ZgGMQIyISBXBs7gIJSRkisjgQAUVkogTmMGxkGvBMhMv4Fj8oPqKK0nyopvkPw\" rel=\"nofollow noreferrer\" title=\"Jelly – Try It Online\">Try it online!</a></p>\n<p><em>-1 thanks to Jonathan Allan</em></p>\n<p>Takes a list of <code>[a, b]</code>. (The dyadic equivalent is the very fun-looking <code>BæcḂḄɓB</code>.)</p>\n<pre><code>B         Convert a and b to their binary digits,\n æc/      and convolve them.\n    Ḃ     Take each mod 2\n     Ḅ    and convert from binary.\n</code></pre>\n"},{"answer_id":78960,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/78960#78960","body":"<h1>Jelly, 16 bytes</h1>\n<pre><code>Ḥ⁴BL’¤Ð¡U×&quot;⁴B¤^/\n</code></pre>\n<p><a href=\"http://jelly.tryitonline.net/#code=4bik4oG0QkzigJnCpMOQwqFVw5ci4oG0QsKkXi8&amp;input=&amp;args=MTM+MTE\" rel=\"nofollow noreferrer\">Try it online!</a></p>\n"},{"answer_id":224916,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/224916#224916","body":"<h1>MMIX, 28 bytes (7 instrs)</h1>\n<p>(jelly xxd)</p>\n<pre><code>00000000: e3020000 7aff0001 c60202ff 3f000001  ẉ£¡¡z”¡¢İ££”?¡¡¢\n00000010: 37010101 5b00fffc f8030000           7¢¢¢[¡”‘ẏ¤¡¡\n</code></pre>\n<p>Disassembly:</p>\n<pre><code>clmul   SETL $2,0       // r = 0\n0H      ZSOD $255,$0,$1 // loop: t = a odd? b : 0\n        XOR  $2,$2,$255 // r ^= t\n        SRU  $0,$0,1    // a &gt;&gt;= 1\n        SLU  $1,$1,1    // b &lt;&lt;= 1\n        PBNZ $0,0B      // iflikely(a) goto loop\n        POP  3,0        // return r\n</code></pre>\n<p>You could get a 128-bit answer out of this with about three more instructions, I think.</p>\n"},{"answer_id":223530,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/223530#223530","body":"<h1><a href=\"https://nodejs.org\" rel=\"nofollow noreferrer\">JavaScript (Node.js)</a>, 29 bytes</h1>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>f=(x,y)=&gt;x&amp;&amp;f(x&gt;&gt;1,y)*2^x%2*y\n</code></pre>\n<p><a href=\"https://tio.run/##RczNCoJAEADg@zzFXBJXTHZ2c01ifZEyVkzDMJWU2J7eRgg6zN/HzDyqdzXXr25a9sN4a9a1taGPP8IWPgja0BcF8RSpq9@p6LOenERCCYQKFeQouTcsBjRqTEFhiiQhwxyNBtJIhKQyYM3wmAIdkDHjBzlfUQ5G8yKbSV0yT323uMvgkmc1hd4WHP6n6OJ6HOaxb5J@vIf@LMvYn6mMF9v@J8FZbWa3KoRYvw\" rel=\"nofollow noreferrer\" title=\"JavaScript (Node.js) – Try It Online\">Try it online!</a></p>\n<p>Similar to <a href=\"https://codegolf.stackexchange.com/a/50246/\">https://codegolf.stackexchange.com/a/50246/</a></p>\n"},{"answer_id":218245,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/218245#218245","body":"<h1>ARM Thumb-2 (NEON), 6 bytes</h1>\n<p>Eat my Thumb, <code>pclmullqlqdqdqdqdq</code>. ARM has boring builtins, too!</p>\n<pre><code>ef80 0e01 4770\n</code></pre>\n<p>Assembly code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>        .syntax unified\n        .arch armv7-a\n        .fpu neon\n        .thumb\n        .globl xormul_boring_neon\n        .thumb_func\nxormul_boring_neon:\n        // q0[0-8] = d0[0-8] @ d1[0-8]\n        vmull.p8 q0, d0, d1\n        bx       lr\n</code></pre>\n<p>Input: two 8-bit values in <code>d0</code> and <code>d1</code>\nOutput: the 16-bit product in <code>q0</code></p>\n<p>This actually multiplies 8 packed bytes together.</p>\n<h1>ARM Thumb-2, manual, 14 bytes</h1>\n<p>Ok, to make up for it, here is a fully scalar version which does a 32x32 multiply with a 32-bit result.</p>\n<pre><code>2300 0849 bf28 4043 0040 d1fa 4770\n</code></pre>\n<p>Assembly code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>        .syntax unified\n        .arch armv6t2\n        .thumb\n        .globl xormul_scalar\n        .thumb_func\n        // r3 &lt;- r0 @ r1\nxormul_scalar:\n        // acc &lt;- 0\n        movs    r3, #0\n.Lloop:\n        // test each bit in y by using lsrs carry-out\n        lsrs    r1, r1, #1\n        // was the bit set?\n        it      cs\n        // if so, acc ^= x\n        eorcs   r3, r0\n        // shift x left\n        lsls    r0, r0, #1\n        // loop while x is non zero\n        bne     .Lloop\n.Lend:\n        // return in r3\n        bx      lr\n</code></pre>\n<p>Equivalent C code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>uint32_t xormul_scalar(uint32_t x, uint32_t y)\n{\n    uint32_t acc = 0;\n    do {\n        if (y &amp; 1)\n            acc ^= x;\n        y &gt;&gt;= 1;\n    } while ((x &lt;&lt;= 1));\n    return acc;\n}\n</code></pre>\n<p>The numbers to be multiplied are in <code>r0</code> and <code>r1</code>, and the result is in <code>r3</code>.</p>\n<p>It is a fairly basic shift and xor loop.</p>\n<p>Yet another case of <code>lsls</code> and <code>lsrs</code> being far too useful than they deserve to be.</p>\n<p><a href=\"https://travis-ci.com/github/easyaspi314/easyaspi-ppcg/jobs/478593577#L439\" rel=\"nofollow noreferrer\">Try it online! (sorta)</a>: demo in Travis</p>\n"},{"answer_id":218243,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/218243#218243","body":"<h1><a href=\"https://www.r-project.org/\" rel=\"nofollow noreferrer\">R</a>, 53 bytes</h1>\n\n<pre class=\"lang-r prettyprint-override\"><code>f=function(x,y)`if`(y,bitwXor(x*y%%2,2*f(x,y%/%2)),0)\n</code></pre>\n<p><a href=\"https://tio.run/##bY/LCsIwEEX38xVFKGTkgibRlgr9D0FEY2ghEB80EZuvr7YV3Lg6cOfMZaYbrOm65JsQTtenj@7hUz20dfu82ejuN9Ej8dm1Z5FwcfG1v3eiX6Y8V1DLdpzmq1wxY81/mkSFkomsiWJBxvssNiFm1oQm7IgWTME8Rs27EAVZsYZkfCihJlaf2pHFN9fQExW2E0tUs68hZ2MLWc7RBnKWZfXdLjQKzcT4Pcd/bu4P8oj@oI7MNLwB\" rel=\"nofollow noreferrer\" title=\"R – Try It Online\">Try it online!</a></p>\n"},{"answer_id":218229,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/218229#218229","body":"<h1><a href=\"https://github.com/DennisMitchell/jelly\" rel=\"nofollow noreferrer\">Jelly</a>, 12 bytes</h1>\n<pre><code>BJ’2*U×B{×^/\n</code></pre>\n<p><a href=\"https://tio.run/##DcwxDsIwEATA/l6xLTTx@fAZFzQp00NJR4PyAUSD@ETEC5AiKgQSER1@ifMRc91qtLvHQ9@fam27@XLzy20e2nMe9k0t31f5POfrY/d7l2nc5HuzqNWB4Yjh4SnBWVYTJYEgkEcAO4pIUCEWMIN9JNOIdSBewTDaQbIVJ1KxopmGPw\" rel=\"nofollow noreferrer\" title=\"Jelly – Try It Online\">Try it online!</a></p>\n<h2>How it works</h2>\n<pre><code>BJ’2*U×B{×^/ - Main link. Takes a on the left, b on the right\nB            - Binary representation of a\n J           - Replace each element with its index\n  ’          - Decrement\n   2*        - Raise each to the power 2\n     U       - Reverse\n       B{    - Yield the binary representation of a\n      ×      - Multiply the bits by the powers\n         ×   - Multiply b by the results\n          ^/ - Reduce by XOR\n</code></pre>\n"},{"answer_id":211435,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/211435#211435","body":"<h1><a href=\"https://nodejs.org\" rel=\"nofollow noreferrer\">JavaScript (Node.js)</a>, 42 bytes</h1>\n<p>Port of the <a href=\"https://codegolf.stackexchange.com/a/50241/95792\">Java answer</a>. Go upvote that!</p>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>x=&gt;y=&gt;(g=i=&gt;i&amp;&amp;g(--i)^x*((y&gt;&gt;i)%2)&lt;&lt;i)(32)\n</code></pre>\n<p><a href=\"https://tio.run/##BcFRCoAgDADQ0xRbYGD12XaUQKxkIS4yok6/3jvCE2q85Lxd0XWznewl/oghkRBL2yZwTnB5O4CPWbAZcJ4FYRzQopaqeeuzJtjBTwh@RLQf\" rel=\"nofollow noreferrer\" title=\"JavaScript (Node.js) – Try It Online\">Try it online!</a></p>\n"},{"answer_id":166326,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/166326#166326","body":"<h1>GNU Assembler(x86_64 Mac OS X), 97 bytes</h1>\n<p>This is a proper function that can be called from C:</p>\n<pre><code>.text\n.globl _f\n_f:\nmovq %rdi,%xmm0;movq %rsi,%xmm1;pclmulqdq $0,%xmm1,%xmm0;movq %xmm0,%rax;ret\n</code></pre>\n<p>&amp; can be tested with this C program:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint f(int a, int b);\n#define p(a,b) printf(&quot;%d %d %d\\n&quot;, a, b, f(a, b))\nint main(void)\n{\n    p(0,1);\n    p(1,2);\n    p(9,0);\n    p(6,1);\n    p(3,3);\n    p(2,5);\n    p(7,9);\n    p(13,11);\n    p(5,17);\n    p(14,13);\n    p(19,1);\n    p(63,63);\n}\n</code></pre>\n<p>Note that on Mac OS X, you have to use <code>clang -x c</code> to compile it as C &amp; not C++.</p>\n<p>For linux(if I remember right), the code would be 95 bytes:</p>\n<pre><code>.text\n.globl f\nf:\nmovq %rdi,%xmm0;movq %rsi,%xmm1;pclmulqdq $0,%xmm1,%xmm0;movq %xmm0,%rax;ret\n</code></pre>\n<p>Strangely enough, this version is actually longer than defining the function in inline assembly, but that one was longer than the pure C solution we already have, so I decided to try assembly.</p>\n<h3>edit</h3>\n<p>If it's counted by the assembled size(excluding any labels &amp;c.), then it's</p>\n<h1>x86_64 Assembler, 22 bytes:</h1>\n<pre><code>0:  66 48 0f 6e c7          movq         %rdi,  %xmm0\n5:  66 48 0f 6e ce          movq         %rsi,  %xmm1\na:  66 0f 3a 44 c1 00       pclmullqlqdq $0,    %xmm1,%xmm0\n10: 66 48 0f 7e c0          movq         %xmm0, %rax\n15: c3                      ret\n</code></pre>\n"},{"answer_id":116709,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/116709#116709","body":"<h1>gnuplot, 29 bytes</h1>\n<pre><code>m(a,b)=a&lt;1?0:a%2*b^m(a/2,b*2)   \n</code></pre>\n<p>just like in Dart (see above)</p>\n"},{"answer_id":67137,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/67137#67137","body":"<h1><a href=\"http://gap-system.org\" rel=\"nofollow\">GAP</a>, 368 Bytes</h1>\n\n<blockquote>\n  <p>For mathematicians, this is multiplication in the polynomial ring F_2[x], identifying polynomials with natural numbers by evaluating at x=2 as a polynomial over Z.</p>\n</blockquote>\n\n<p>Sure, let's do that! (this is only loosly golfed, the point was more to move into F<sub>2</sub>[x] and do the calculations more than any attempt at being a winning entry)</p>\n\n<p>Here's the code </p>\n\n<pre><code>f:=function(i,j)R:=PolynomialRing(GF(2));x:=IndeterminatesOfPolynomialRing(R);x:=x[1];a:=function(i)local n,r;r:=0*x;while not i=0 do n:=0;while 2^n&lt;=i do n:=n+1;od;n:=n-1;r:=r+x^n;i:=i-2^n;od;return r;end;b:=function(r)local c,i,n;i:=0;n:=0;for c in CoefficientsOfUnivariatePolynomial(r) do if c=Z(2)^0 then n:=n+2^i;fi;i:=i+1;od;return n;end;return b(a(i)*a(j));end;\n</code></pre>\n\n<p>Here's the ungolfed code with explanation:</p>\n\n<pre><code>xor_multiplication:=function(i,j)           \n    R:=PolynomialRing(GF(2));\n    x:=IndeterminatesOfPolynomialRing(R);\n    x:=x[1];\n    to_ring:=function(i)\n        local n,r; \n        r:=0*x;\n        while not i=0 do\n            n:=0;\n            while 2^n&lt;=i do\n                n:=n+1;\n            od;\n            n:=n-1;\n            r:=r+x^n;\n            i:=i-2^n;\n        od;\n        return r;\n    end;\n    to_ints:=function(r)\n        local c,i,n;\n        i:=0;n:=0;\n        for c in CoefficientsOfUnivariatePolynomial(r) do\n            if c=Z(2)^0 then\n                n:=n+2^i;\n            fi;\n            i:=i+1;\n        od;\n        return n;\n    end;\n    return to_ints( to_ring(i)*to_ring(j));\nend;\n</code></pre>\n\n<p>Okay, so first off, we create the univariate polynomial ring over the field F<sub>2</sub> and call it <code>R</code>. Note that <code>GF(2)</code> is F<sub>2</sub> in GAP.</p>\n\n<pre><code>R:=PolynomialRing(GF(2));\n</code></pre>\n\n<p>Next, we are going to assign the GAP variable <code>x</code> to the indeterminate of the ring <code>R</code>. Now, whenever I say <code>x</code> in GAP, the system will know I am talking about the indeterminate of the ring <code>R</code>. </p>\n\n<pre><code>x:=IndeterminatesOfPolynomialRing(R);\nx:=x[1];\n</code></pre>\n\n<p>Next, we have two functions, which are inverse maps of each other. These maps are both onto, but they are not structure preserving, so I couldn't figure out a better way to implement them in GAP. There almost certainly is a better way, if you know it, please comment!</p>\n\n<p>The first map, <code>to_ring</code> takes an integer and maps it to its corresponding ring element. It does this by using a conversion to binary algorithm, where every <code>1</code> that would appear in binary is replaced by an <code>x^n</code> where <code>n</code> is the appropriate power that 2 would take if the number was indeed binary. </p>\n\n<pre><code>    to_ring:=function(i)\n        local n,r; \n        r:=0*x;                 # initiate r to the zero element of R\n        while not i=0 do        # this is a modified binary algorithm\n            n:=0;\n            while 2^n&lt;=i do\n                n:=n+1;\n            od;\n            n:=n-1;\n            r:=r+x^n;\n            i:=i-2^n;\n        od;\n        return r;\n    end;\n</code></pre>\n\n<p>The next function reverses this. <code>to_ints</code> takes a ring element and maps it to its corresponding integer. I do this by getting a list of the coefficients of the polynomial and for each nonzero coefficient, the result is increased by 2^n, in the same way that we would convert binary to decimal. </p>\n\n<pre><code>    to_ints:=function(r)\n        local c,i,n;\n        i:=0;n:=0;\n        for c in CoefficientsOfUnivariatePolynomial(r) do\n            if c=Z(2)^0 then          \n\n                 # ^-- Right here you'll notice that the Z(2) is basically '1' in GF(2). So Z(2)^0 ~ 1 and Z(2)*0 ~ 0  \n                 # effectively, this line checks for nonzero coefficients\n\n                n:=n+2^i;\n            fi;\n            i:=i+1;\n        od;\n        return n;\n    end;\n</code></pre>\n\n<p>For the final step, we call these functions. We take the two integer inputs, convert them into elements in the ring <code>R</code>, then multiply these elements together, and send the product back to the integers. </p>\n\n<pre><code>return to_ints( to_ring(i)*to_ring(j));\n</code></pre>\n"},{"answer_id":66942,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/66942#66942","body":"<h2>Ceylon, 90 bytes</h2>\n\n<pre class=\"lang-ceylon prettyprint-override\"><code>alias I=&gt;Integer;I x(I a,I b)=&gt;[for(i in 0:64)if(b.get(i))a*2^i].fold(0)((y,z)=&gt;y.xor(z));\n</code></pre>\n\n<p>This is just the algorithm as described: multiply <code>a</code> by <code>2^i</code> wherever the <code>i</code>th bit is set in <code>b</code>, and add them all together using xor. Iterates over <code>0:64</code> because Integers are 64-bit in Ceylon when running on JVM (lower when running as Javascript, but then <code>b.get(i)</code> just returns false).</p>\n\n<p>Formatted:</p>\n\n<pre class=\"lang-ceylon prettyprint-override\"><code>alias I =&gt; Integer;\n\nI x(I a, I b) =&gt;\n      [\n        for (i in 0:64)\n            if (b.get(i))\n                a * 2^i\n      ].fold(0)((y, z) =&gt; y.xor(z));\n</code></pre>\n\n<p>The alias safes here just a single byte.</p>\n"},{"answer_id":50267,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50267#50267","body":"<h1>Julia, <s>35</s> <s>33</s> 30 bytes</h1>\n\n\n\n<pre class=\"lang-julia prettyprint-override\"><code>f(a,b)=b%2*a$(b&gt;0&amp;&amp;f(2a,b÷2))\n</code></pre>\n\n<p>This creates a recursive function <code>f</code> which takes two integers and returns the XOR product of the inputs.</p>\n\n<p>Ungolfed:</p>\n\n<pre class=\"lang-julia prettyprint-override\"><code>function f(a, b)\n    # Bitwise XOR : $\n    # Short-circuit AND : &amp;&amp;\n\n    b % 2 * a $ (b &gt; 0 &amp;&amp; f(2a, b ÷ 2))\nend\n</code></pre>\n\n<p>Saved a couple bytes with encouragement from Sp3000!</p>\n"},{"answer_id":50400,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50400#50400","body":"<h1>Go, 63 bytes</h1>\n<pre><code>func f(a,b uint)uint{if a&lt;1{return 0};return a%2*b^f(a/2,b*2)}\n</code></pre>\n<p>Complete example:</p>\n<p><a href=\"http://play.golang.org/p/-ngNOnJGyM\" rel=\"nofollow noreferrer\">http://play.golang.org/p/-ngNOnJGyM</a></p>\n"},{"answer_id":50261,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50261#50261","body":"<h2>Dart, <s>34</s> 32 bytes</h2>\n\n\n\n<pre class=\"lang-dart prettyprint-override\"><code>m(a,b)=&gt;a&lt;1?0:a%2*b^m(a~/2,b*2);\n</code></pre>\n\n<p>Straight-forward recursive implementation.</p>\n"},{"answer_id":50307,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50307#50307","body":"<h1>Mathematica, 40 bytes</h1>\n<pre><code>BitXor@@(#2BitAnd[#,2^Range[0,Log2@#]])&amp;\n</code></pre>\n"},{"answer_id":50291,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50291#50291","body":"<h1>x86 machine code: 7 bytes</h1>\n<pre><code>66 0F 3A 44 C1 00 C3  pclmulqdq xmm0, xmm1, 0 \\ ret\n</code></pre>\n<p>Only two instructions. <code>pclmulqdq</code> does the heavy lifting, it literally implements that type of xor-multiplication. <code>ret</code> to make it a callable function, hopefully satisfying the requirement of &quot;outputting&quot; the result (in the return value, <code>xmm0</code>). Putting integer arguments in <code>xmm</code> args is a bit unusual, but I hope you'll forgive me.</p>\n"},{"answer_id":50273,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50273#50273","body":"<h2>Perl - 35 Bytes</h2>\n\n\n\n<pre class=\"lang-perl prettyprint-override\"><code>#!perl -p\n$\\^=$`&gt;&gt;$_&amp;1&amp;&amp;$'&lt;&lt;$_ for-/ /..31}{\n</code></pre>\n\n<p>Counting the command line option as one. Input is taken from <code>STDIN</code>, space separated.</p>\n\n<p><strong>Sample usage:</strong></p>\n\n<pre class=\"lang-perl prettyprint-override\"><code>$ echo 13 11 | perl xormul.pl\n127\n$ echo 5 17 | perl xormul.pl\n85\n$ echo 14 13 | perl xormul.pl\n70\n$ echo 19 1 | perl xormul.pl\n19\n$ echo 63 63 | perl xormul.pl\n1365\n</code></pre>\n"},{"answer_id":50275,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50275#50275","body":"<h1>Z80, 11 bytes</h1>\n\n<pre><code>B7 CB 32 30 01 B3 C8 CB 23 18 F6   \n</code></pre>\n\n<p>The code is called as a function. <code>a</code> and <code>b</code> are in <code>D</code> and <code>E</code> (the order doesn't matter) and the answer is stored in <code>A</code> when the code returns (there are no I/O functions).</p>\n\n<pre><code>B7      XOR A     //  A^=A (A=0)\nCB 32   SRL D     //    CARRY = lsb(D), D&gt;&gt;=1, ZERO = D==0\n30 01   JR NC, 1  //    jump 1 byte if not CARRY\nB3      XOR E     //      A^=E, ZERO = A==0\nC8      RET Z     //    return if ZERO\nCB 23   SLA E     //    E&lt;&lt;=1\n18 F6   JR -10    //    jump -10 bytes\n</code></pre>\n\n<p>It produces the correct results for all test input except <code>63@63</code> which returns <code>85</code> because all the registers are 8-bit and 1365 mod 256 = 85 (integer overflow).</p>\n"},{"answer_id":50269,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50269#50269","body":"<h2>Ruby, <s>76</s> <s>75</s> 73 bytes</h2>\n\n<pre><code>a,b=$*.map{|x|x.to_i}\no=0\nwhile(b&gt;0)\no^=a&amp;-(b&amp;1)\na&lt;&lt;=1\nb&gt;&gt;=1\nend\nputs(o)\n</code></pre>\n\n<h1>Ruby, 60 bytes (function only, no I/O)</h1>\n\n<pre><code>def t(a,b)\no=0\nwhile(b&gt;0)\no^=a&amp;-(b&amp;1)\na&lt;&lt;=1\nb&gt;&gt;=1\nend\nt\nend\n</code></pre>\n"},{"answer_id":50268,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50268#50268","body":"<h1>Python 2, 35 bytes</h1>\n<pre class=\"lang-py prettyprint-override\"><code>f=lambda m,n:n and n%2*m^f(2*m,n/2)\n</code></pre>\n<p>Call like <code>f(13, 14)</code>. I think most languages with a similar construct will converge on something like this.</p>\n"},{"answer_id":50246,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50246#50246","body":"<h1>C, <s>44</s> 38 bytes</h1>\n<p><em>Thanks to nimi, we now use recursion for 6 fewer bytes!</em></p>\n\n<pre class=\"lang-c prettyprint-override\"><code>f(a,b){return b?(b&amp;1)*a^f(a*2,b/2):0;}\n</code></pre>\n<p>We define a function <code>f</code> which takes <code>a</code>, <code>b</code>.</p>\n<p>This can be called like:</p>\n<pre class=\"lang-c prettyprint-override\"><code>printf(&quot;%d @ %d = %d\\n&quot;, 13, 14, f(13, 14));\n</code></pre>\n<p>Which outputs:</p>\n<p><code>13 @ 14 = 70</code></p>\n<p>Try the test cases <a href=\"http://ideone.com/MaJPpL\" rel=\"noreferrer\">online</a>!</p>\n"},{"answer_id":50259,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50259#50259","body":"<h1>Haskell, 50 bytes</h1>\n\n<pre><code>import Data.Bits\n_#0=0\na#b=b.&amp;.1*a`xor`2*a#div b 2\n</code></pre>\n\n<p>A translation of @BrainSteel's C answer. Usage example:</p>\n\n<pre><code>map (uncurry (#)) [(0,1),(1,2),(9,0),(6,1),(3,3),(2,5),(7,9),(13,11),(5,17),(14,13),(19,1),(63,63)]\n[0,2,0,6,5,10,63,127,85,70,19,1365]\n</code></pre>\n"},{"answer_id":50244,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50244#50244","body":"<h1>Python 2, <s>104</s> <s>91</s> <s>78</s> 66 bytes</h1>\n\n<pre class=\"lang-python prettyprint-override\"><code>def y(a,b,c=0):\n for _ in bin(b)[:1:-1]:c^=int(_)*a;a&lt;&lt;=1\n print c\n</code></pre>\n<p>Take the bits of <code>b</code> in reverse order, ending before you hit the <code>'0b'</code> at the start of the string. Multiply each one by <code>a</code> and <code>xor</code> with the total, then left-shift <code>a</code>. Then print the total.</p>\n"},{"answer_id":50248,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50248#50248","body":"<h1>CJam, <s>14</s> 13 bytes</h1>\n<pre><code>q~2bf*{\\2*^}*\n</code></pre>\n<p><strong>How it works</strong>:</p>\n<p>We first get the long multiplication results and then work our way up starting from the bottom two pairs.</p>\n<pre><code>q~                e# Eval the input. This puts the two numbers on stack\n  2b              e# Convert the second number to binary\n    f*            e# Multiply each bit of second number with the first number\n                  e# This leaves an array with the candidates to be added in the long\n                  e# multiplication step\n      {    }*     e# Reduce on these candidates. Starting from the bottom\n       \\2*        e# Bit shift the lower candidate\n          ^       e# XOR each other and continue\n</code></pre>\n<p><a href=\"http://cjam.aditsu.net/#code=q%7E2bf*%7B%5C1m%3C%5E%7D*&amp;input=14%2013\" rel=\"nofollow noreferrer\">Try it online here</a></p>\n"},{"answer_id":50249,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50249#50249","body":"<h1><a href=\"http://mniip.com/misc/conv/golflua/\" rel=\"nofollow noreferrer\">golflua</a> 68</h1>\n\n<pre class=\"lang-lua prettyprint-override\"><code>x,y=I.r(&quot;*n&quot;,&quot;*n&quot;)r=0~@i=0,31r=B.x(r,x*B.ls(B.rs(y,i)%2,i+1))$w(r/2)\n</code></pre>\n<p>Does basically the same bitshifting as <a href=\"https://codegolf.stackexchange.com/a/50241/11376\">Ypnypn's Java answer</a>, but seems to require the divide by 2 at the end to work correctly. Takes in values as stdin, examples below</p>\n<pre class=\"lang-lua prettyprint-override\"><code>&gt; 14 13 \n70\n&gt; 19 1 \n19\n&gt; 5 17 \n85\n</code></pre>\n"},{"answer_id":50241,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50241#50241","body":"<h1>Java, 62</h1>\n\n\n\n<pre class=\"lang-java prettyprint-override\"><code>(x,y)-&gt;{int r=0,i=0;for(;i&lt;32;)r^=x*((y&gt;&gt;i)%2)&lt;&lt;i++;return r;}\n</code></pre>\n\n<h2>Expanded</h2>\n\n<pre class=\"lang-java prettyprint-override\"><code>class XORMultiplication {\n    public static void main(String[] args) {\n        IntBinaryOperator f = (x, y) -&gt; {\n                    int r = 0, i = 0;\n                    for (; i &lt; 32;) {\n                        r ^= x * ((y &gt;&gt; i) % 2) &lt;&lt; i++;\n                    }\n                    return r;\n                };\n        System.out.println(f.applyAsInt(14, 13));\n    }\n}\n</code></pre>\n"},{"answer_id":50243,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50243#50243","body":"<h1>J, 14 bytes</h1>\n\n<pre><code>*/(~://.@)&amp;.#:\n</code></pre>\n\n<p>Usage:</p>\n\n<pre><code>   5 (*/(~://.@)&amp;.#:) 17     NB. enclosing brackets are optional\n85\n</code></pre>\n\n<p>Explanation (reading mostly from right to left; <code>u</code> and <code>v</code> stand for arbitrary functions):</p>\n\n<ul>\n<li><code>u&amp;.#:</code> applies <code>u</code> to the vectors of the binary representations of the input numbers then turn the result back to an integer (<code>u&amp;.v == v_inverse(u(v(input_1), v(input_2)))</code>)</li>\n<li><code>*/</code> products (<code>*</code>) of inputs in the Descartes product (<code>/</code>) of the two binary vector</li>\n<li><code>v(u@)</code> apply <code>u</code> to <code>v</code> (to the Descartes product)</li>\n<li><code>u/.</code> apply <code>u</code> to every anti-diagonal of the Descartes product (anti-diagonals represent the 1st, 2nd, ... digits in the binary representation)</li>\n<li><code>~:/</code> reduce (<code>/</code>) an anti-diagonal with XOR operation (<code>~:</code>)</li>\n<li>The last step is generating an integer from the binary vector which the first point takes care of.</li>\n</ul>\n\n<p><a href=\"http://tryj.tk/\" rel=\"noreferrer\">Try it online here.</a></p>\n"},{"answer_id":50245,"question_id":50240,"link":"https://codegolf.stackexchange.com/questions/50240/xor-multiplication/50245#50245","body":"<h1>Pyth, <s>13</s> 12 bytes</h1>\n<pre><code>uxyG*HQjvz2Z\n</code></pre>\n<p><a href=\"https://pyth.herokuapp.com/?code=xFm*vz.%26Q%5E2dQ&amp;input=63%0A63&amp;debug=0\" rel=\"noreferrer\">Demonstration.</a></p>\n<pre><code>uxyG*HQjvz2Z\n                  Implicit:\n                  z = input()\n                  Q = eval(input())\n                  Z = 0\n\n       jvz2       The first input, written in base 2, like so: [1, 0, 1, ...\nu      jvz2Z      Reduce over the binary representation, starting with 0.\n x                XOR of\n  yG              Twice the previous number\n    *HQ           and the second input times the current bit.\n</code></pre>\n<hr />\n<p>Old version, 13 bytes:</p>\n<pre><code>xFm*vz.&amp;Q^2dQ\n</code></pre>\n<p><a href=\"https://pyth.herokuapp.com/?code=xFm*vz.%26Q%5E2dQ&amp;input=13%0A11&amp;debug=0\" rel=\"noreferrer\">Demonstration.</a></p>\n"}]