[{"answer_id":274287,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274287#274287","body":"<h1><a href=\"https://www.uiua.org/\" rel=\"nofollow noreferrer\">Uiua</a>, 18 bytes</h1>\n<pre><code>°⋯∊:⊟⊃(↥1/↧)/↥./+⋯\n</code></pre>\n<p>Takes decimal input</p>\n<p><a href=\"https://www.uiua.org/pad?src=0_12_0-dev_2__ZiDihpAgwrDii6_iiIo64oqf4oqDKOKGpTEv4oanKS_ihqUuLyvii68KZiBbMV0KZiBbMl0KZiBbMSAyIDVdCmYgWzQyOTQ5NjcyOTVdCmYgWzI0NTQyNjcwMjYgMjg2MzMxMTUzMCAzNjgxNDAwNTM5XQpmIFsyMzQxMTAzOTQ1IDI5NjkxMTI1MDYgMTg0OTA3ODk0OSAxNDMwNjM5MTg5XQo=\" rel=\"nofollow noreferrer\">Try it!</a></p>\n<pre><code>°⋯∊:⊟⊃(↥1/↧)/↥./+⋯\n                 ⋯  # convert to binary (padding with zeroes),\n               /+   # get bitsums,\n            /↥      # find the maximum\n    ⊟⊃              # and\n      (↥1/↧)        # the non-zero minimum,\n  ∊:          .     # set bits that are one of the two,\n°⋯                  # and convert back to decimal\n</code></pre>\n"},{"answer_id":274260,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274260#274260","body":"<h1><a href=\"https://raku.org\" rel=\"nofollow noreferrer\">Raku (Perl 6) (rakudo)</a>, <s>102</s> 99 bytes</h1>\n<pre class=\"lang-perl prettyprint-override\"><code>{{[+] 2 &lt;&lt;**&lt;&lt;grep @^b.max|@b.grep(*&gt;0).min,:k,@b}([Z+] (|$_,0)&gt;&gt;.polymod(2 xx.max.base(2).chars))}\n</code></pre>\n<p><a href=\"https://ato.pxeger.com/run?1=LU5bboMwEPznFKsoqmzqWH5jNxRxjkZtBWloq5QQQSOBCCfpDx9p79TbxCT52Z2dnZndn1OdbQ_jX9nBXfH4e_guFvZ_3fer-2cQEMdhGMfv9WYP6UtOy6w9pjmdZhQmDNPyc0cetiTNB7R68g50nL8ShpOE7quvrqzekIC2nXw0z5oNEpiuP7K6wXi4nTotg6KqASFOMAEkLpUTEAT0BJVwyplIOH3dK62EiZgwXmKNlJxryQhIY7liTEt3UUnFOZNOaa9yxnEuNPMObpVjkfWJHivJjHTcOoxhkcB8B30A0GQdzDz2TF94cpgtg9uv43jtZw\" rel=\"nofollow noreferrer\">Attempt This Online!</a></p>\n"},{"answer_id":274263,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274263#274263","body":"<h1><a href=\"https://github.com/mudkip201/pyt\" rel=\"nofollow noreferrer\">Pyt</a>, 31 bytes</h1>\n<pre><code>2⁴⁸Đ←+ɓąƖĐŁ⑴⊤·ĐĐŁř1=¬*ž↕∈Ɩǰ2Ĩ⇹%\n</code></pre>\n<p><a href=\"https://tio.run/##AXYAif9weXT//zLigbTigbjEkOKGkCvJk8SFxpbEkMWB4pG04oqkwrfEkMSQxYHFmTE9wqwqxb7ihpXiiIjGlsewMsSo4oe5Jf//WzIzNDExMDM5NDUsIDI5NjkxMTI1MDYsIDE4NDkwNzg5NDksIDE0MzA2MzkxODld\" rel=\"nofollow noreferrer\" title=\"Pyt – Try It Online\">Try it online!</a></p>\n<pre><code>2⁴⁸Đ                              push 2^32 twice\n    ←                             get input\n     +                            add 2^32 to input (to ensure same-length bit strings)\n      ɓ                           get binary strings\n       ąƖ                         convert each to list of bits\n         ĐŁ⑴⊤·                   get # of occurrences of each bit\n               ĐĐŁř=¬*            get rid of the pesky fake first entry\n                      ž           remove zeroes\n                       ↕          get minimum and maximum\n                        ∈         is each bitsum either min or max?\n                         Ɩǰ       cast to integer, then concatenate\n                           2Ĩ     interpret as binary number\n                             ⇹    flip top two on the stack\n                              %   modulo 2^32\n</code></pre>\n<p>The last two steps only come into play when there is only one number in the input.</p>\n"},{"answer_id":274261,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274261#274261","body":"<h1><a href=\"https://nodejs.org\" rel=\"nofollow noreferrer\">JavaScript (Node.js)</a>, 91 bytes</h1>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>f=A=&gt;A.some((x,i)=&gt;t=A[k=i-1]&amp;~x)?f(A,A[k]^=t,A[k+1]^=t):(A.some(x=&gt;t=x),A[k+1]^A[k]|t)&gt;&gt;&gt;0\n</code></pre>\n<p><a href=\"https://tio.run/##jZDNasMwEITvfoqcipQqiVZ/lgJS0XMYB0JqF7dJFGJTdCh9dVcqySFFh552mNnZhe99/7kfD9fhMq3O4bWb59566/x6DKcOoUgGbN1kffNhhxW0T98Rv/TIk2S0Ozvl@QxZ4S26lWIuRHyP8ubXhJ1zdD6E8xiO3foY3lCPGmgxrv54rOABYUQWfMGMMKpmphQyIQVTNWWKLJhWnANITsmCKw2CUslNqcQFAOVGyFQyygAwSdMB0MLQWqd3SQtOFTegfw9Um2VVQBZ3yDdDBvPA7gHef5BVy838Aw\" rel=\"nofollow noreferrer\" title=\"JavaScript (Node.js) – Try It Online\">Try it online!</a></p>\n<p>Bubble sort</p>\n"},{"answer_id":71400,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/71400#71400","body":"<h1>Jelly</h1>\n<p><strong>14 bytes</strong></p>\n<pre><code>BUSµḟ0Ṣ.ịe€@UḄ\n</code></pre>\n<p><a href=\"http://jelly.tryitonline.net/#code=QlVTwrXhuJ8w4bmiLuG7i2XigqxAVeG4hA&amp;input=&amp;args=WzIzNDExMDM5NDUgLDI5NjkxMTI1MDYgLDE4NDkwNzg5NDkgLDE0MzA2MzkxODld\" rel=\"nofollow noreferrer\">Try it online!</a></p>\n<h3>How it works</h3>\n<pre><code>BUSµḟ0Ṣ.ịe€@UḄ    Main link. Input: A (list)\n\nB                 Convert each item in A to binary.\n U                Reverse each array of binary digits.\n  S               Add them across columns.\n\n   µ              Monadic chain. Argument: S (list of column sums)\n    ḟ0            Remove all occurrences of 0.\n      Ṣ           Sort the remaining sums.\n       .ị         Take the elements with indices around 0.5.\n                  Indices are 1-bases, so this selects the last and the first one.\n             U    Yield S, reversed.\n            @     Reverse the arguments.\n         e€       Test each item in the left list for membership in the right one.\n              Ḅ   Convert from binary to integer.                \n            \n</code></pre>\n"},{"answer_id":63384,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63384#63384","body":"<h1><a href=\"http://esolangs.org/wiki/Brainfuck\" rel=\"noreferrer\">Brainfuck</a>, 619 bytes</h1>\n<p>First answer in far too long here, so I thought I'd do a good one!</p>\n<pre><code>&gt;-&gt;-&gt;-&gt;&gt;&gt;,----------[--&lt;++++++[&gt;------&lt;-]&gt;&gt;&gt;&gt;,----------]-&lt;&lt;&lt;+[-&lt;&lt;&lt;+]-&gt;&gt;,&lt;++++[&gt;--------&lt;-]&gt;[&lt;++++[&gt;+++++&lt;-]&gt;++[--&lt;++++++[&gt;------&lt;-]&gt;&gt;&gt;+&gt;]&lt;-[+&gt;-&lt;&lt;+[-&lt;&lt;&lt;+]-&lt;&lt;+[-&gt;+[-&gt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+]+[--&gt;&gt;&gt;++]-&lt;+]&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;+&gt;]&lt;-[+&gt;-&gt;&gt;&gt;&gt;+[-&gt;&gt;&gt;+]-&gt;+[-&lt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+]+[--&gt;&gt;&gt;++]-&gt;+]-&lt;+&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;]]&gt;,&lt;++++[&gt;--------&lt;-]&gt;]&gt;+[-&gt;&gt;&gt;+]&gt;-&gt;-&gt;&gt;-[+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;-&lt;&lt;+]-&gt;&gt;[+&gt;&gt;&gt;[&gt;&gt;&gt;]&gt;+[&lt;&lt;-&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]+&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;-&gt;]&lt;]&gt;-&gt;&gt;+&gt;-]&lt;[&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-]&gt;+[-&gt;&gt;&gt;+]-&gt;&gt;-]&gt;-[+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-&gt;&gt;&gt;[&gt;&gt;&gt;]&gt;+[&lt;&lt;&lt;-&gt;&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;&gt;+&gt;]&lt;]&gt;-&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;+[-&gt;[-]&lt;[-&gt;+&lt;]&lt;[-&gt;&gt;[-]+&lt;&lt;]&lt;&lt;+]&gt;-[+&gt;&gt;&gt;-]++[-&gt;++++++[-&lt;++++++++&gt;]&lt;.&gt;&gt;&gt;+]\n</code></pre>\n<p>Did... Did I win?</p>\n<p>This program expects newlines (ASCII <code>10</code>) after every binary number, and requires a space (ASCII <code>32</code>) at the end.</p>\n<p>Test runs:</p>\n<pre><code>Me$ bf bpx.bf\n1\n10\n101\n \n111\n\nMe$ bf bpx.bf\n11111111111111111111111111111111\n \n11111111111111111111111111111111\n\nMe$ bf bpx.bf\n10010010010010010010010010010010\n10101010101010101010101010101010\n11011011011011011011011011011011\n \n11100011100011100011100011100011\n\nMe$ bf bpx.bf\n10001011100010100110100101001001\n10110000111110010000111110111010\n1101110001101101011010010100101\n1010101010001011101001001010101\n \n11\n</code></pre>\n<p>(Newlines added after each case with <code>++++++++++.</code> added at the end of the program)</p>\n<h1>Explanation</h1>\n<p>Still a work in progress, but a slow one. For lack of time, I've just copied the notes I made whilst writing this program, which will suffice for an explanation for now:</p>\n<pre><code>[Biplex Calculator]\n\n[\n\nBitsum writing philosophy: \n\nStart with [0 255 255 255 ...].\nThe 255s will be markers that we can 'search' for to get back to the start.\nAfter that, the next byte should be a 0, fairly permanently. (The first reference 0)\nIt is useful to have 0-bytes handy for general calculations. \nThe next byte is where we will read the first digit of any binary number. (The first read)\nThe next byte holds the first bitsum.\nAfterward, the next byte is 0, the following byte is the place\nto read the second binary digit, the following byte is the second bitsum,\nand so on.\nI'll use the terminology nth reference 0, nth read, and nth bitsum to refer to\neach part of the triplet of bytes.\n\nThe location three places after the final bitsum will be 255,\nand the location three places after the final read will be 255.\nWe can move entire numbers by lining up these 255s after every binary number.\n\n]\n\n\n&gt;-&gt;-&gt;-&gt;&gt;&gt;~                  [0 255 255 255 0 0 0 0 0                ]\n\n[From the first bitsum, read input to create an initial set of bitsums                  ]\n,----------\n[\n    --&lt;++++++[&gt;------&lt;-]            [Convert the input '1' or '0' into a bit        ]\n    &gt;&gt;&gt;&gt;,---------- \n]~                      \n-&lt;&lt;&lt;+[-&lt;&lt;&lt;+]-&gt;&gt;                 [Mark 255 after the last bit, then go back to first read]\n\n,&lt;++++[&gt;--------&lt;-]             [Check for space, using the first reference 0       ]\n&gt;\n[\n    &lt;++++[&gt;+++++&lt;-]             [Check for \\n                       ]\n    &gt;++\n    [\n        --&lt;++++++[&gt;------&lt;-]        [It wasn't \\n, so convert the input into a bit      ]\n        &gt;&gt;&gt;+&gt;               [Write 1 to the next reference 0, and go to next read   ]\n    ]\n    &lt;-\n    [\n        +&gt;              [It was \\n                      ]\n        -&lt;              [Mark 255 on this (nth) read and go to (n-1)th bitsum   ]\n        &lt;+[-&lt;&lt;&lt;+]           [Search for a 255 off to the left           ]\n\n        [We've either struck our marker, or the last bitsum. We need to check.          ]\n        -&lt;&lt;+\n        [\n            -           [We hit the last bitsum. Move the bitsums right.    ]\n            &gt;+\n            [\n                -&gt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+] [Move until we reach the start          ]\n                +[--&gt;&gt;&gt;++]      [From the start, move to our last bitsum    ]\n                [Repeat this move until the read here is a 255              ]\n                -&lt;+\n            ]\n            [We now need to go to the first reference zero, and put a 1 there       ]\n            &lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;+&gt;      [Add bits to bitsums and end on first read  ]\n        ]\n        &lt;-\n        [\n            +&gt;-&gt;&gt;&gt;&gt;+[-&gt;&gt;&gt;+]     [Go to the 255 after our reads              ]\n            -&gt;+\n            [\n                -&lt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+] [Move until we reach the start          ]\n                +[--&gt;&gt;&gt;++]      [From the start, move to the 255 after our reads]\n                [Repeat this move until we see the 255 bitsum               ]\n                -&gt;+\n            ]\n            [We now need to go to the first read                        ]\n            -&lt;+&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;     [Add bits to bitsums and end on first read  ]\n        ]\n        &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;~&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    ]\n    \n    [We're at the reference 0 to the left of our next read                      ]\n    &gt;,&lt;++++[&gt;--------&lt;-]            [Check for space, using the first reference 0       ]\n    &gt;\n]\n\n[\n\nLet BN be the nth bitsum. Then our situation at the moment is:\n\n[0 255 255 255 0 0 B1 0 0 B2 ... 0 0 BN 0 0 255] \n                 ^\nI'm just happy nothing's exploded yet.\n\n]\n\n[Next goal: Mark the minimums                                       ]\n\n&gt;+[-&gt;&gt;&gt;+]&gt;-&gt;-&gt;&gt;~            [Zero the 255 and put 2 255s after it, then move after it   ]\n\n-[\n    +&lt;&lt;&lt;&lt;&lt;&lt;\n    +[-&lt;-&lt;&lt;+]               [Subtract one from each bitsum              ]\n    -&gt;&gt;\n    [\n        +&gt;&gt;&gt;[&gt;&gt;&gt;]           [Find the first 0 bitsum                ]\n        &gt;+\n        [\n            &lt;&lt;-&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]     [Mark the zero as a minimum, and set a flag     ]\n            +&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;-&gt;\n        ]\n        &lt;\n    ]\n    &gt;-&gt;&gt;+&gt;-\n]~\n\n[Hey, that worked. Weird. Alright, moving on...                             ]\n[Reset the bitsums to what they were before we messed them all up                   ]\n\n&lt;[&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-]&gt;+[-&gt;&gt;&gt;+]-&gt;&gt;-]&gt;~\n\n[After the stuff up there, that's not too bad.                              ]\n[Now it's time to mark the maximums, in virtually the opposite way we did the minimums.         ]\n\n-[\n    +&lt;&lt;&lt;&lt;&lt;&lt;\n    +[-&lt;+&lt;&lt;+]               [Add one to each bitsum                 ]\n    -&gt;&gt;\n    [\n        -&gt;&gt;&gt;[&gt;&gt;&gt;]           [Find the first 0 bitsum                ]\n        &gt;+\n        [\n            &lt;&lt;&lt;-&gt;&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]   [Mark the zero as a maximum, and set a flag     ]\n            +&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;&gt;+&gt;\n        ]\n        &lt;\n    ]\n    &gt;-&gt;&gt;&gt;-\n]~\n\n[Alright, now OR the maxs and mins, take care of leading zeros, output, and cross fingers       ]\n&lt;&lt;&lt;&lt;-&gt;&gt;~&lt;&lt;&lt;&lt;&lt;&lt;~+[-&gt;[-]&lt;[-&gt;+&lt;]&lt;[-&gt;&gt;[-]+&lt;&lt;]&lt;&lt;+]&gt;-[+&gt;&gt;&gt;-]++[-&gt;++++++[-&lt;++++++++&gt;]&lt;.&gt;&gt;&gt;+]\n</code></pre>\n"},{"answer_id":63612,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63612#63612","body":"<h1>C++, 192 bytes</h1>\n<p>Accepts input a 32 bit unsigned integer array, and a count of items in that array.</p>\n<pre><code>typedef unsigned long U;U b(U*a,int c){U x[32],t,i,j,M=0,m=c,r=0;for(i=0;i&lt;32;x[i++]=t,m=t&amp;&amp;m&gt;t?t:m,M=M&lt;t?t:M)for(t=j=0;j&lt;c;)t+=a[j++]&gt;&gt;i&amp;1;for(i=0;i&lt;32;++i)r|=(x[i]==m||x[i]==M)&lt;&lt;i;return r;}\n</code></pre>\n<p>Ungolfed :</p>\n<pre><code>unsigned long b(unsigned long*a, int c){\n    unsigned long x[32],t,i,j,M=0,m=c,r=0;\n    for(i=0;i&lt;32;x[i++]=t){\n        m = (t &amp;&amp; m &gt; t)?t:m;\n        M = M &lt; t ? t:M;\n        for(t=j=0;j&lt;c;){\n            t+=a[j++]&gt;&gt;i&amp;1;\n        }\n    }\n    for(i=0;i&lt;32;++i)\n        r|=(x[i]==m||x[i]==M)&lt;&lt;i;\n    return r;\n}\n</code></pre>\n"},{"answer_id":63680,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63680#63680","body":"<h1>GolfScript, 46 bytes</h1>\n\n<pre><code>~{2base-1%}%zip{{+}*}%-1%.$0-)\\1&lt;|`{&amp;,}+%2base\n</code></pre>\n\n<p>Try it online on <a href=\"http://golfscript.apphb.com/?c=OyAiWzIzNDExMDM5NDUgMjk2OTExMjUwNiAxODQ5MDc4OTQ5IDE0MzA2MzkxODldIiAjIFNpbXVsYXRlIGlucHV0IGZyb20gU1RESU4uCgp%2BezJiYXNlLTElfSV6aXB7eyt9Kn0lLTElLiQwLSlcMTx8YHsmLH0rJTJiYXNl\" rel=\"nofollow\">Web GolfScript</a>.</p>\n\n<h3>Test cases</h3>\n\n<pre><code>$ golfscript biplex.gs &lt;&lt;&lt; '[1]'\n1\n$ golfscript biplex.gs &lt;&lt;&lt; '[2]'\n2\n$ golfscript biplex.gs &lt;&lt;&lt; '[1 2 5]'\n7\n$ golfscript biplex.gs &lt;&lt;&lt; '[4294967295]'\n4294967295\n$ golfscript biplex.gs &lt;&lt;&lt; '[2454267026 2863311530 3681400539]'\n3817748707\n$ golfscript biplex.gs &lt;&lt;&lt; '[2341103945 2969112506 1849078949 1430639189]'\n3\n</code></pre>\n"},{"answer_id":63640,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63640#63640","body":"<h1>Wolfram Language, 113 bytes</h1>\n\n<p>This version takes input from a popup window, with the numbers being input in the form \"{x,y,z,...}\", (no quotes).</p>\n\n<pre><code>FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@Input[]]\n</code></pre>\n\n<p>Input:</p>\n\n<p><img src=\"https://i.sstatic.net/WIi1t.png\" alt=\"popup window dynamic\"></p>\n\n<p>Output:</p>\n\n<p><img src=\"https://i.sstatic.net/OM2bi.png\" alt=\"output\"></p>\n\n<p>Takes input in a dynamic Manipulate as a string of the form \"{x,y,z}\" with x, y, and z being base 10 integers (with or without leading zeroes). The output is also in base 10.</p>\n\n<pre><code>Manipulate[FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@ToExpression@i],{i,\"{1}\"}]\n</code></pre>\n\n<p><img src=\"https://wolfr.am/8apzjEPd\" alt=\"example\"></p>\n\n<p>There are other ways to input this in a way that would save on character counts, but I think this solution is an elegant use of a dynamic GUI that performs the computation</p>\n\n<p>If you want to run this in the cloud, we can use CloudDeploy:</p>\n\n<pre><code>o=CloudDeploy[FormPage[{\"i\"-&gt;\"String\"},(FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@ToExpression@#i])&amp;]];SetOptions[o,Permissions-&gt;{All-&gt;{\"Read\",\"Execute\"},\"Owner\"-&gt;{\"Read\",\"Write\",\"Execute\"}}];o\n</code></pre>\n\n<p>The Cloud deploy brings the character count up to 256 however...</p>\n\n<p>The input to the FormPage is also a string of the form \"{x,y,z}\" with x, y, and z being base 10 integers.</p>\n\n<p>I cloud-deployed this myself and you can try it out at <a href=\"https://www.wolframcloud.com/objects/97b512df-64f8-4cae-979b-dba6d9622781\" rel=\"nofollow noreferrer\">https://www.wolframcloud.com/objects/97b512df-64f8-4cae-979b-dba6d9622781</a></p>\n\n<p><img src=\"https://i.sstatic.net/C8BbN.png\" alt=\"cloud example\"></p>\n"},{"answer_id":63509,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63509#63509","body":"<h1><a href=\"https://github.com/DennisMitchell/ShapeScript\" rel=\"nofollow\">ShapeScript</a>, 186 bytes</h1>\n\n<pre><code>'\"1\n\"$0?_1-\"+\"*\":2\"@~@\"0\n\"~\"0\n\"$\"\n\"~+'1?_*!\"2\"$\"0\"~\"\n\"$\"\"~\":\"1?'@1?\"+\"$_1&gt;\"+\"*+@1?\"0\"+$\"\"~'1?_*!#\"0\"+@\":+\"'1?1?\"0\"+$_2&lt;\"+\"*+'1?_*!\"0\"+$\"1\"~@$\"1\"~\":\"$\"\"~\"+\"$\"\"~'\"\n\"@+\"\n0\"$\"\"~'1?_*!\"\n\"$\"\"~\n</code></pre>\n\n<p>An important, useless language for an important, useless operator.</p>\n\n<p>I/O is in binary. The program expects each number on a separate line, each ending with a linefeed.</p>\n\n<p><a href=\"http://shapescript.tryitonline.net/#code=JyIxCiIkMD9fMS0iKyIqIjoyIkB-QCIwCiJ-IjAKIiQiCiJ-KycxP18qISIyIiQiMCJ-IgoiJCIifiI6IjE_J0AxPyIrIiRfMT4iKyIqK0AxPyIwIiskIiJ-JzE_XyohIyIwIitAIjorIicxPzE_IjAiKyRfMjwiKyIqKycxP18qISIwIiskIjEifkAkIjEifiI6IiQiIn4iKyIkIiJ-JyIKIkArIgowIiQiIn4nMT9fKiEiCiIkIiJ-&amp;input=MTAwMDEwMTExMDAwMTAxMDAxMTAxMDAxMDEwMDEwMDEKMTAxMTAwMDAxMTExMTAwMTAwMDAxMTExMTAxMTEwMTAKMTEwMTExMDAwMTEwMTEwMTAxMTAxMDAxMDEwMDEwMQoxMDEwMTAxMDEwMDAxMDExMTAxMDAxMDAxMDEwMTAxCg==\" rel=\"nofollow\">Try it online!</a></p>\n\n<h3>Test cases</h3>\n\n<pre><code>$ echo -e '1' | shapescript biplex.shape; echo\n1\n$ echo -e '10' | shapescript biplex.shape; echo\n10\n$ echo -e '1\\n10\\n101' | shapescript biplex.shape; echo\n111\n$ echo -e '11111111111111111111111111111111' | shapescript biplex.shape; echo11111111111111111111111111111111\n$ echo -e '10010010010010010010010010010010\\n10101010101010101010101010101010\\n11011011011011011011011011011011' | shapescript biplex.shape; echo\n11100011100011100011100011100011\n$ echo -e '10001011100010100110100101001001\\n10110000111110010000111110111010\\n1101110001101101011010010100101\\n1010101010001011101001001010101' | shapescript biplex.shape; echo\n11\n</code></pre>\n"},{"answer_id":63627,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63627#63627","body":"<h1>CoffeeScript, 194 bytes</h1>\n\n<p>Takes input as coma separated binary numbers, outputs in binary. </p>\n\n<pre><code>a=(s.split('').reverse()for s in prompt().split(','))\nfor i in b=[0..31]\n b[i]=0\n b[i]+=+c[31-i]||0for c in a\nm=1/M=0\nfor d in b\n M=d if d&gt;M;m=d if m&gt;d&amp;&amp;d\nalert +(+(d in[m,M])for d in b).join ''\n</code></pre>\n\n<p><a href=\"http://coffeescript.org/#try:a%3D(s.split(&#39;&#39;).reverse()for%20s%20in%20prompt().split(&#39;%2C&#39;))%0Afor%20i%20in%20b%3D%5B0..31%5D%0A%20b%5Bi%5D%3D0%0A%20b%5Bi%5D%2B%3D%2Bc%5B31-i%5D%7C%7C0for%20c%20in%20a%0Am%3D1%2FM%3D0%0Afor%20d%20in%20b%0A%20M%3Dd%20if%20d%3EM%3Bm%3Dd%20if%20m%3Ed%26%26d%0Aalert%20%2B(%2B(d%20in%5Bm%2CM%5D)for%20d%20in%20b).join%20&#39;&#39;\" rel=\"nofollow\">Try it.</a></p>\n"},{"answer_id":63484,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63484#63484","body":"<h1>Ruby, 127 bytes</h1>\n<pre><code>def f l;a=[];32.times{|i|a[i]=0;l.each{|n|;a[i]+=n[i]}};a.map{|b|a.reject{|c|c==0}.minmax.index(b)?1:0}.reverse.join.to_i 2;end\n</code></pre>\n<p>Takes an array as input.</p>\n"},{"answer_id":63389,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63389#63389","body":"<h1>APL, 27 bytes</h1>\n\n<pre><code>{2⊥S∊(⌈/,⌊/)0~⍨S←+/⍵⊤⍨32⍴2}\n</code></pre>\n\n<p>This is a monadic function that takes a list of decimal integers and returns their decimal biplex.</p>\n\n<p>Try it online in the <a href=\"http://ngn.github.io/apl/web/#code=%7B2%u22A5S%u220A%28%u2308/%2C%u230A/%290%7E%u2368S%u2190+/%u2375%u22A4%u236832%u23742%7D%20%A8%20%28%2C1%29%20%28%2C2%29%20%281%202%205%29%20%28%2C4294967295%29%20%282454267026%202863311530%203681400539%29%20%282341103945%202969112506%201849078949%201430639189%29\" rel=\"nofollow\">ngn/apl demo</a>.</p>\n\n<h3>How it works</h3>\n\n<pre><code>                     32⍴2  Create a list of 32 2's.\n                  ⍵⊤⍨      Base-encode the right argument.\n                +/         Add the corresponding binary digits.\n              S←           Save the sums in S.\n           0~⍨             Remove 0's.\n    (⌈/,⌊/)                Apply minimum (⌊/), maximum (⌈/) and concatenate.\n  S∊                       Check which binary digits are in the extrema list.\n2⊥                         Convert from base 2 to integer.\n</code></pre>\n"},{"answer_id":62873,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62873#62873","body":"<h2><a href=\"https://github.com/elendiastarman/Minkolang\" rel=\"noreferrer\">Minkolang 0.10</a>, <s>109</s> 79 bytes</h2>\n<pre><code>(n1$(d2%$r2:d)99*I-DmI2:[+1R]$I)rI$d$(s0(x0gd,)Ik3R2g1-X0I3-[2*2gd0c=$r1c=++]N.\n</code></pre>\n<p>Input and output are in decimal. <a href=\"http://play.starmaninnovations.com/minkolang/old?code=%28n1%24%28d2%25%24r2%3Ad%2999%2AI-DmI2%3A%5B%2B1R%5D%24I%29rI%24d%24%28s0%28x0gd%2C%29Ik3R2g1-X0I3-%5B2%2A2gd0c%3D%24r1c%3D%2B%2B%5DN%2E&amp;input=2341103945%2C+2969112506%2C+1849078949%2C+1430639189\" rel=\"noreferrer\">Try it here.</a></p>\n<h3>Explanation</h3>\n<pre><code>(                            $I)    Loop until input is empty\n n                                  Read in number from input\n  1$(       d)                      Start a while loop with only the top of stack\n     d2%                            Next least-significant bit (modulo by 2)\n        $r                          Swap top two values\n          2:                        Divide by 2\n              99*I-D                Pad with 0s\n                                    (when the while loop exits, top of stack is 0)\n                    m               Merge (interleave) stack\n                     I2:[   ]       For each pair...\n                         +1R        Add and rotate stack to the right\n                                    &lt;&lt;This does the work of computing bitsums&gt;&gt;\n\nr       Reverse stack\n I      Push length of stack\n  $d    Duplicate whole stack\n        &lt;&lt;This lets me sort the bitsums without affecting the original order&gt;&gt;\n\n$(                      Start while loop with &lt;top of stack&gt; elements\n  s                     Sort\n   0(     )             Push a 0 and start another while loop\n     x                  Dump top of stack\n      0g                Get front of stack and put it on top\n        d,              Duplicate and &lt;not&gt; for end-while condition check\n           Ik           Push length of stack and break out of while loop\n             3R         Rotate [min, max, length] to front\n               2g1-     Get length and put it on top, then subtract 1\n                   X    Dump that many elements off the top of stack\n                        &lt;&lt;Now I have min and max&gt;&gt;\n\n0                        Initialize decimal with 0    \n I3-[               ]    For as many bits as there are...\n     2*                  Multiply by 2\n       2gd               Get the next most significant bit and put it on top\n          0c=            Copy min and check for equality\n             $r          Swap top two elements of stack\n               1c=       Copy max and check for equality\n                  ++     Add 1 if bitsum item is equal to min or max, 0 otherwise\nN.                       Output as integer and stop\n</code></pre>\n<hr />\n<h3>Old version:</h3>\n<pre><code>$nI[(d2%i1+0a+i1+0A00ai`4&amp;i00A2:d)x]00a1+[i1+0a]s0(x0gd,)rI2-[x]00a1+[i1+0ad0c=$r1c=+]0gx0gx0(xd,)0I1-[2*+]N.\n</code></pre>\n<p><a href=\"http://play.starmaninnovations.com/minkolang/?code=%24nI%5B%28d2%25i1%2B0a%2Bi1%2B0A00ai%604%26i00A2%3Ad%29x%5D00a1%2B%5Bi1%2B0a%5Ds0(x0gd%2C)rI2-%5Bx%5D00a1%2B%5Bi1%2B0ad0c%3D%24r1c%3D%2B%5D0gx0gx0(xd%2C)0I1-%5B2*%2B%5DN%2E&amp;input=2341103945%2C%202969112506%2C%201849078949%2C%201430639189\" rel=\"noreferrer\">Try it here!</a></p>\n<h3>Explanation</h3>\n<p>The crux of it is that the <strong>array</strong> feature is heavily used (<code>a A</code>) to store the bitsums, of which the minimum and maximum are found, then <code>1</code>s and <code>0</code>s are outputted appropriately, with dumping of leading <code>0</code>s in two places.</p>\n<pre><code>$n                                      Read in whole input as integers\n  I[(                             x]    Convert each number to binary\n     d2%                                Get next least significant bit (modulo by 2)\n        i1+0a                           Get current value in array for that position\n             +                          Add\n              i1+0A                     Put current value in array for that position\n                   00ai`                Get first value of array (bitsum length)\n                      i`                Greater than loop counter?\n                        4&amp;i00A          If not, put loop counter there\n                              2:        Divide by 2\n                                d)      If 0, exit loop\n\n00a                Get first value of array (maximum length\n   1+              Add one\n     [i1+0a]       Get bitsum values from array and push on stack\n            s      Sort\n0(                 Push a 0 (for dump) and start a while loop -- dumps leading 0s\n  x                Dump top of stack\n   0g              Get bottom of stack\n     d,            Duplicate and &lt;not&gt; it\n       )           Exit loop when top of stack is non-zero (i.e., the minimum)\n        r          Reverse stack (so now it's [min, max, &lt;stuff&gt;])\n         I2-[x]    Dump everything else\n\n00a1+[               ]    Get bitsum length and loop that many times\n      i1+0a               Get bitsum value at current position\n           d              Duplicate\n            0c=           Copy front of stack and check for equality\n               $r         Swap\n                 1c=      Copy next-to-front of stack and check for equality\n                    +     Add (so it's 1 if it's equal to min or max, 0 otherwise)\n\n0gx0gx       Dump front two elements of stack (the min and max)\n0(xd,)       Dump leading 0s\n0            Push 0 for conversion to decimal\n I1-[   ]    For each bit...\n     2*+     Multiply by 2 and add\nN.           Output as integer and stop\n</code></pre>\n"},{"answer_id":62923,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62923#62923","body":"<h1>J, <s>31</s> <s>30</s> <s>24</s> <s>23</s> 21 bytes</h1>\n\n<pre><code>+/(e.&gt;./,&lt;./@#~@)&amp;.#:\n</code></pre>\n\n<p>This is a tacit, monadic verb that takes a list of decimal integers and returns their decimal biplex.</p>\n\n<p><em>Thanks to @Zgarb for his suggestions, which saved 4 bytes directly and paved the way for 2 more!</em></p>\n\n<p><em>Thanks to @randomra for golfing off 2 more bytes!</em></p>\n\n<h3>Test cases</h3>\n\n<pre><code>   biplex =: +/(e.&gt;./,&lt;./@#~@)&amp;.#:\n\n   biplex ,1\n1\n   biplex ,2\n2\n   biplex 1 2 5\n7\n   biplex ,4294967295\n4294967295\n   biplex 2454267026 2863311530 3681400539\n3817748707\n   biplex 2341103945 2969112506 1849078949 1430639189\n3\n</code></pre>\n\n<h3>How it works</h3>\n\n<pre><code>                 &amp;.    Dual. Apply the verb to the right, the verb to the left,\n                       and finally the inverse of the verb to the right.\n                   #:  Convert the input list from integer to base 2.\n  (            @)      Define an adverb, i.e., an operator that takes a verb as\n                       its left argument.\n+/                     Call it with \"reduce by sum\". This calculates the sum of\n                       the corresponding binary digits of all integers before\n                       executing the remainder of the adverb's body, i.e, this:\n             #~          Replicate the sum N a total of N times, i.e., turn\n                         0 1 2 3 into 1 2 2 3 3 3. This eliminates zeroes.\n         &lt;./@            Calculate the minimum of the result.\n     &gt;./                 Calculate the maximum of the sums.\n        ,                Append; wrap both extrema into a list.\n   e.                    Check if each of the sums is in the list of extrema.\n                         This yields 1 if yes and 0 if no.\n                       (from &amp;.) Convert from base 2 to integer.\n</code></pre>\n"},{"answer_id":63212,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63212#63212","body":"<h1>Javascript, <strike>154</strike> 150 bytes</h1>\n<pre><code>t=i=&gt;(m=0,r=[],i.map(n=&gt;{for(j=31;j+1;r[k=31-j]=(r[k]|0)+((n&gt;&gt;&gt;j)%2),--j);}),r.map(n=&gt;m=(n==Math.min(...r.filter(x=&gt;x))|n==Math.max(...r)?1:0)+m*2),m)\n</code></pre>\n<p>Thanks for edc65 method for min/max calculation, it shortened my code by 4 bytes.</p>\n<h1>Explanation</h1>\n<pre><code>t=i=&gt;(\n    m=0,//m=&gt;output\n    r=[],//Bitsum then final number in binary\n    i.map(\n        n=&gt;\n        {\n            //Decimal to binary + bitsum\n            for(j=31;j+1;r[k=31-j]=(r[k]|0)+((n&gt;&gt;&gt;j)%2),--j);\n        }),\n    //Output formatting\n    r.map(\n        n=&gt;\n            m=(n==Math.min(...r.filter(x=&gt;x))|n==Math.max(...r)?1:0)+m*2\n        ),\n    m\n)\n</code></pre>\n"},{"answer_id":63100,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63100#63100","body":"<h1>C#, 255</h1>\n<p>A complete program, input as command line arguments - space separated - in decimal.</p>\n\n<pre class=\"lang-cs prettyprint-override\"><code>using System.Linq;class P{static void Main(string[]l){var n=new uint[32];uint i,r=0,b;foreach(var v in l)for(i=0,b=uint.Parse(v);b!=0;b/=2)n[i++]+=b&amp;1;b=1;foreach(var v in n){r+=(v==n.Max()|v== n.Min(x=&gt;x&gt;0?x:n.Max()))?b:0;b+=b;}System.Console.Write(r);}}\n</code></pre>\n<p>More readable:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>using System.Linq;\n\nclass P\n{\n    static void Main(string[] l)\n    {\n        var n = new uint[32];\n        uint i, r = 0, b;\n\n        foreach (var v in l)\n            for (i = 0, b = uint.Parse(v); b != 0; b /= 2) n[i++] += b &amp; 1;\n        b = 1;\n        foreach (var v in n)\n        {\n            r += (v == n.Max() | v == n.Min(x =&gt; x &gt; 0 ? x : n.Max())) ? b : 0;\n            b += b;\n        }\n        System.Console.Write(r);\n    }\n}\n</code></pre>\n\n"},{"answer_id":63095,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63095#63095","body":"<h2>Python 3, <s>181</s> <s>126</s> 122 bytes</h2>\n<p>(I took out most of the byte count slashes because it was getting a bit ridiculous.) 21 bytes off thanks to <strong>Sp3000</strong>!</p>\n<pre><code>*z,=map(sum,zip(*[map(int,t.zfill(99))for t in input().split()]))\nk=0\nfor x in z:k=k*10+(x in[min(z)or 1,max(z)])\nprint(k)\n</code></pre>\n<p>Slightly less golfed:</p>\n<pre><code>s=input().split()\nk=list(map(lambda t:list(map(int,t))[::-1],s))\nz=list(map(sum,zip(*k)))\ny=z[:]\nwhile min(y)==0:y.remove(0)\na,b=min(y),max(y)\nf=''.join(map(lambda x:str(1*(x in[a,b])),z[::-1]))\nprint(int(f))\n</code></pre>\n<p>Input is expected in binary with only spaces separating the numbers. Output is in binary as well.</p>\n"},{"answer_id":62908,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62908#62908","body":"<h1>Haskell, <s>198</s> <s>182</s> <s>178</s> 161 character</h1>\n<p>I'm still beginner at golfing. Only 80 reputation comes from answer.</p>\n<pre><code>m=map\nv=reverse\n(b:x)&amp;(c:y)=(b+c):x&amp;y\n[]&amp;a=a\nb&amp;_=b\nl=(show=&lt;&lt;).v.(\\a-&gt;m(fromEnum.(`elem`[maximum a,minimum$(replicate=&lt;&lt;id)=&lt;&lt;a]))a).foldl1(&amp;).m(m(read.(:[])).v)\n</code></pre>\n<p>How does it work.</p>\n<p>Instead of padding, I reverse the array then I add using user defined (&amp;). I don't use foldl1(zipWith(+)) that is shorter because zipWith will delete the superflous item. Then I find the maximum and nonzero minimum, that also required user defined function. Then I match the item with the maximum and nonzero minimum, 1 if match, 0 if it doesn't match. Then we reverse and turn it into binary number.</p>\n<p>TODO:</p>\n<ol>\n<li>Using <code>Data.List</code></li>\n</ol>\n"},{"answer_id":62928,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62928#62928","body":"<h1>JavaScript (ES6), 158</h1>\n\n<p>A function with a numeric array parameter, returning a number. With the same byte count it could get a string array parameter (containing base 2 rapresentations) and return a base 2 string - just move the <code>.toString(2)</code> at the end after <code>r</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>f=l=&gt;(l.map(v=&gt;[...v.toString(2)].reverse().map((x,i)=&gt;t[i]=~~t[i]-x),t=[]),t.map(v=&gt;(r+=v==Math.min(...t)|v==Math.max(...t.filter(x=&gt;x))&amp;&amp;b,b+=b),r=0,b=1),r)\r\n\r\n// More readable\r\n\r\nu=l=&gt;(\r\n  t=[],\r\n  l.map(v =&gt;\r\n    [...v.toString(2)]\r\n    .reverse()\r\n    .map((x,i) =&gt; t[i] = ~~t[i] - x)\r\n  ),\r\n  r=0,b=1,\r\n  t.map(v =&gt; (\r\n    r += v==Math.min(...t) | v==Math.max(...t.filter(x=&gt;x)) &amp;&amp; b, b+=b\r\n  )),\r\n  r\r\n)\r\n\r\n// Test\r\nconsole.log=s=&gt;O.innerHTML+=s+'\\n'\r\n\r\n;[\r\n [[1], 1]\r\n,[[2], 2]\r\n,[[1, 2, 5], 7]\r\n,[[4294967295], 4294967295]\r\n,[[2454267026, 2863311530, 3681400539], 3817748707]\r\n,[[2341103945, 2969112506, 1849078949, 1430639189], 3]\r\n].forEach(t =&gt;{ \r\n  r=f(t[0])\r\n  x=t[1]\r\n  console.log('Test '+(r==x?'OK':'Fail (Expected: ' + x +')')\r\n  +'\\nInput: '+t[0]+'\\nResult: ' +r+'\\n')                       \r\n})  </code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"answer_id":62731,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62731#62731","body":"<h1>JavaScript (ES6), <strike>215</strike> <strike>185</strike> 176 bytes</h1>\n\n<pre class=\"lang-js prettyprint-override\"><code>f=a=&gt;{s=[];for(i of a)for(b=i.toString(2),d=l=b.length;d--;)s[x=l-d-1]=(s[x]|0)+(b[d]|0);q=255;for(r of s)d=r&gt;d?r:d,q=r&lt;q?r||q:q;o=\"\";s.map(r=&gt;o=(r==q|r==d)+o);return+(\"0b\"+o)}\n</code></pre>\n\n<h2>Usage</h2>\n\n<pre class=\"lang-js prettyprint-override\"><code>f([2454267026, 2863311530, 3681400539])\n=&gt; 3817748707\n</code></pre>\n\n<h2>Explanation</h2>\n\n<pre class=\"lang-js prettyprint-override\"><code>f=a=&gt;{\n\n  // Create an array of bitsums\n  s=[];                   // s = bitsums\n  for(i of a)             // iterate through the passed array of numbers\n    for(\n      b=i.toString(2),    // b = number as binary string\n      d=l=b.length;       // l = number of digits in b\n      d--;                // iterate through each digit of the binary string\n    )\n      s[x=l-d-1]=         // add to the digit of the bitsum array\n        (s[x]|0)+         // get the current value of the bitsum array (or 0 if null)\n        (b[d]|0);         // add the result to the bitsum array\n\n  // Get the maximum and minimum bitsums\n  q=255;                  // q = min bitsum\n  //d=0;                  // d = max bitsum\n  for(r of s)             // iterate through the bitsums\n    d=r&gt;d?r:d,            // set d to maximum\n    q=r&lt;q?r||q:q;         // set q to minimum\n\n  // Calculate the result\n  // (unfortunately JavaScript only supports bitwise operations on signed 32-bit\n  // integers so the temporary binary string is necessary)\n  o=\"\";                   // o = output\n  s.map(r=&gt;               // iterate through the bitsum digits\n    o=(r==q|r==d)+o       // add a 1 to the string if the digit is equal to min or max\n  );\n  return+(\"0b\"+o)         // convert the binary string to a number\n}\n</code></pre>\n"},{"answer_id":62925,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62925#62925","body":"<h1>Python 3, 197</h1>\n<pre><code>import itertools\no='0'\nd=[sum(map(int,n))for n in itertools.zip_longest(*map(reversed,input().split(' ')),fillvalue=o)]\nm=max(d),min(d)or 1\nprint(''.join((o,'1')[g in m]for g in d[::-1]).lstrip(o))\n</code></pre>\n<p>It takes in space delimited binary numbers.</p>\n<p>Ungolfed version:</p>\n<pre><code>import itertools\nnums = map(reversed, input().split(' '))\ndigits = []\nfor num in itertools.zip_longest(*nums, fillvalue='0'):\n    current_digit = sum(map(int,num))\n    digits.append(current_digit)\nbit_max = max(digits)\nbit_min = min(digits) or min(digits) + 1\nprint(''.join(('0','1')[digit in(bit_max,bit_min)]for digit in digits[::-1]).lstrip('0'))\n</code></pre>\n"},{"answer_id":62900,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62900#62900","body":"<h1>Octave, 50 bytes</h1>\n\n<pre><code>@(a)[\"\" ((b=sum(a-48))==max(b)|b==min(b(b&gt;0)))+48]\n</code></pre>\n\n<p><strong>Example:</strong></p>\n\n<pre><code>octave:1&gt; g = @(a)[\"\" ((b=sum(a-48))==max(b)|b==min(b(b&gt;0)))+48] ;\noctave:2&gt; g([\"10010010010010010010010010010010\"; \"10101010101010101010101010101010\"; \"11011011011011011011011011011011\"])\nans = 11100011100011100011100011100011\n</code></pre>\n"},{"answer_id":62896,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62896#62896","body":"<h1>Julia, 141 bytes</h1>\n\n\n\n<pre class=\"lang-julia prettyprint-override\"><code>A-&gt;(s=reduce(.+,map(i-&gt;digits(i,2,maximum(map(i-&gt;ndigits(i,2),A))),A));parse(Int,reverse(join([1(i∈extrema(filter(j-&gt;j&gt;0,s)))for i=s])),2))\n</code></pre>\n\n<p>Ungolfed:</p>\n\n<pre class=\"lang-julia prettyprint-override\"><code>function biplex(A::AbstractArray)\n    # Get the maximum number of binary digits in each element\n    # of the input array\n    L = maximum(map(i -&gt; ndigits(i, 2), A))\n\n    # Create an array of arrays of binary digits corresponding\n    # to the inputs\n    B = map(i -&gt; digits(i, 2, L), A)\n\n    # Get the bitsums\n    S = reduce(.+, B)\n\n    # Replace the minimum and maximum bitsums with ones and\n    # the rest with zeros\n    s = [1 * (i in extrema(filter(j -&gt; j &gt; 0, S))) for i in S]\n\n    # Join this into a string and parse it as a base 2 integer\n    # Reverse is required because digits() returns the digits\n    # in reverse order\n    p = parse(Int, reverse(join(s)), 2)\n\n    return p\nend\n</code></pre>\n"},{"answer_id":62729,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62729#62729","body":"<h1><a href=\"http://conorobrien-foxx.github.io/Simplex/\" rel=\"nofollow\">Simplex v.0.7</a>, 38 bytes</h1>\n\n<p><em>Simpl</em>ified comments. Input in Binary, no interpreter working at the moment. Hopefully the comments are sufficient.</p>\n\n<pre><code>hj&amp;=j&amp;Lun?&amp;RvRpp]{Ri}^XKRJ@jqLhR@LhuTo\nh               ]                        ~~ define macro 0\n j&amp;                                      ~~ insert a new byte and write register to it\n   =                                     ~~ equal to the previous byte?\n    j&amp;                                   ~~ insert a new byte and write register to it\n      L                                  ~~ return to equality\n       u    v                            ~~ go up/down a strip\n        n?&amp;                              ~~ write the register iff byte = 0\n           R                             ~~ go right\n             Rpp                         ~~ remove two bytes\n                 {Ri}                    ~~ take input until input = 0\n                     ^X                  ~~ take the sum of the strip\n                       K                 ~~ split that sum into digits\n                        RJ@              ~~ take the max; write to register\n                           jq            ~~ take the min\n                             Lh          ~~ call macro 0\n                               R@        ~~ set min to register\n                                 Lh      ~~ apply macro 0\n                                   uTo   ~~ output result \n</code></pre>\n"},{"answer_id":62717,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62717#62717","body":"<h1>Pyth, <s>26</s> 25 bytes</h1>\n\n<pre><code>JsM.T_MjR2Qi_}RhM_BS-J0J2\n</code></pre>\n\n<p>Try it online: <a href=\"http://pyth.herokuapp.com/?code=JsM.T_MjR2Qi_%7DRhM_BS-J0J2&amp;input=[2454267026%2C+2863311530%2C+3681400539]&amp;test_suite_input=[1]%0A[2]%0A[1%2C+2%2C+5]%0A[4294967295]%0A[2454267026%2C+2863311530%2C+3681400539]%0A[2341103945%2C+2969112506%2C+1849078949%2C+1430639189]&amp;debug=0\">Demonstration</a> or <a href=\"http://pyth.herokuapp.com/?code=JsM.T_MjR2Qi_%7DRhM_BS-J0J2&amp;input=[2454267026%2C+2863311530%2C+3681400539]&amp;test_suite=1&amp;test_suite_input=[1]%0A[2]%0A[1%2C+2%2C+5]%0A[4294967295]%0A[2454267026%2C+2863311530%2C+3681400539]%0A[2341103945%2C+2969112506%2C+1849078949%2C+1430639189]&amp;debug=0\">Test Suite</a></p>\n\n<h3>Explanation</h3>\n\n<pre><code>JsM.T_MjR2Q\n       jR2Q      convert each input number to binary (lists of 1s and 0s)\n     _M          reverse each list\n   .T            transpose (with top justify)\n sM              sum up each list (numbers of 1s at each position)\nJ                store this list in J\n\ni_}RhM_BS-J0J2\n         -J0     J without 0s\n        S        sorted\n      _B         create the list [sorted, reverse(sorted)]\n    hM           take the first elments of each (bitsum-min and bitsum-max)\n  }R        J    check for each value in J, if it is part of ^\n _               reverse this list of booleans\ni            2   convert from binary to base 10 and print\n</code></pre>\n"},{"answer_id":62714,"question_id":62713,"link":"https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62714#62714","body":"<h2>CJam, 27 bytes</h2>\n\n<pre><code>q~2fbWf%:.+_0-$(\\W&gt;|fe=W%2b\n</code></pre>\n\n<p>Takes input as a base-10 CJam-style list. <a href=\"http://cjam.aditsu.net/#code=q~2fbWf%25%3A.%2B_0-%24(%5CW%3E%7Cfe%3DW%252b&amp;input=2454267026%202863311530%203681400539%5D\" rel=\"nofollow\">Test it here.</a> Alternatively, <a href=\"http://cjam.aditsu.net/#code=qN%2F%7B%22%3D%3E%22%2F0%3D&#39;%2C-%3AQ%3B%0A%0AQ~2fbWf%25%3A.%2B_0-%24(%5CW%3E%7Cfe%3DW%252b%0A%0A%5DoNo%7D%2F&amp;input=%5B1%5D%20%3D%3E%201%0A%5B2%5D%20%3D%3E%202%0A%5B1%2C%202%2C%205%5D%20%3D%3E%207%0A%5B4294967295%5D%20%3D%3E%204294967295%0A%5B2454267026%2C%202863311530%2C%203681400539%5D%20%3D%3E%203817748707%0A%5B2341103945%2C%202969112506%2C%201849078949%2C%201430639189%5D%20%3D%3E%203\" rel=\"nofollow\">run all test cases</a> (the script discards the expected output and converts the input format as necessary).</p>\n\n<h3>Explanation</h3>\n\n<pre><code>q~    e# Read and evaluate input.\n2fb   e# Convert each number to base 2.\nWf%   e# Reverse each digit list, to align digits in case there are numbers with different \n      e# widths.\n:.+   e# Add up the bit planes.\n_0-   e# Make a copy and remove zeroes.\n$     e# Sort the bit plane sums.\n(\\W&gt;| e# Get the first and last element. We use set union instead of addition so that the\n      e# resulting array will contain only one value if min = max.\nfe=   e# For each element in the bit plane sums, count how often it appears in the min/max\n      e# array, which is either 1 or 0.\nW%    e# Reverse the digits again (to undo the initial reversing).\n2b    e# Interpret as base-2 digits.\n</code></pre>\n"}]